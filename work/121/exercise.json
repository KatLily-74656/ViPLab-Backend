{"Exercise":{
      "comment": "",
      "config": {"Matlab": {
            "interpreting": {"flags": ""},
            "merging": {"sources": [
                  "codeFromStudent",
                  "epilog1"
            ]},
            "checking" :
            {
              "sources": ["codeFromStudent"],
              "allowedCalls": "fprintf linspace cos ones abs max ceil sum plot title axis zeros sin fprintf diag sqrt eig gamma length find setdiff figure global clear hold"
            },
            "stopAfterPhase": "interpreting"
      }},
      "description": "Interpolation einer Kurve",
      "elements": [
            {
                  "MIMEtype": "text/plain",
                  "emphasis": "Low",
                  "identifier": "epilog1",
                  "modifiable": false,
                  "name": "",
                  "syntaxHighlighting": "Matlab",
                  "value": "% Overwrites the built-in plot function and gives out\n% a ViPLab graphic format file (.vgf).\n% It behaves similar to built-in plot function except\n% that complex values are forbitten and X values must\n% be provided for every plot.\n% \n% The arguments are X, Y and an optional LineSpec. These\n% two or three arguments can be appended multiple times.\n% X contains the x values of the points, Y the y values.\n% Consecutive points are drawn connected by a line.\n% X and Y must have one matching dimension if at least\n% one is a vector and must have the exact same dimension\n% if moth are matrices.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-08\n%%%\n\nfunction plot(X, Y, varargin)\n\t\n\t%%%\n  % ensure valid arguments\n  assert(not(isempty(X)), 'X must not be empty.');\n\tassert(not(isempty(Y)), 'Y must not be empty.');\n  assert(isnumeric(X), 'X must be numeric.');\n\tassert(isnumeric(Y), 'Y must be numeric.');\n  assert(not(isscalar(X)) || isvector(Y), 'If X is scalar Y must be a vector.');\n\tassert(not(isvector(X) && not(isscalar(X)) && isvector(Y)) || (length(X) == length(Y)), 'Vectors X and Y must have same dimensions.');\n\tassert(not(isvector(X) && not(isscalar(X)) && size(Y, 1) > 1 && size(Y, 2) > 1) || (length(X) == size(Y, 1) || length(X) == size(Y, 2)), 'Vector X and matrix Y must have one dimension in common.');\n\tassert(not(size(X, 1) > 1 && size(X, 2) > 1 && isvector(Y)) || (size(X, 1) == length(Y) || size(X, 2) == length(Y)), 'Matrix X and vector Y must have one dimension in common.');\n\tassert(not(size(X, 1) > 1 && size(X, 2) > 1 && size(Y, 1) > 1 && size(Y, 2) > 1) || isequal(size(X),size(Y)), 'Matrices X and Y must have same dimensions.');\n    \n  %%%\n\t% open file to append, use UTF-8 encoding\n  plot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\n\t%%%\n\t% handle optional arguments\n\tLineSpec = '';\n\tnewArgIn = {};\n\t% if first optional argument is a string, it's the line specification\n\tif (size(varargin, 2) == 1) && ischar(varargin{1})\n\t\tLineSpec = varargin{1};\n\t% pass remaining optional arguments to next plot call\n\telseif (size(varargin, 2) > 1) && ischar(varargin{1})\n\t\tLineSpec = varargin{1};\n\t\tnewArgIn = varargin(2:size(varargin, 2));\n\telseif (size(varargin, 2) > 0)\n\t\tnewArgIn = varargin;\n\tend; %if\n\n\t%%%\n  % write color data\n  if length(LineSpec) > 0\n\t\tif not(isempty(strfind(LineSpec, 'r')))\n\t\t\tfprintf(plot_file, '# color 255 0 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'b')))\n\t\t\tfprintf(plot_file, '# color 0 0 255\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'g')))\n\t\t\tfprintf(plot_file, '# color 0 255 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'c')))\n\t\t\tfprintf(plot_file, '# color 0 255 255\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'm')))\n\t\t\tfprintf(plot_file, '# color 255 0 255\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'y')))\n\t\t\tfprintf(plot_file, '# color 255 255 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'k')))\n\t\t\tfprintf(plot_file, '# color 0 0 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'w')))\n\t\t\tfprintf(plot_file, '# color 255 255 255\\n');\n\t\tend; %if\n\t\n\t%%%\n  % write symbol data\n\t\tif not(isempty(strfind(LineSpec, 'x')))\n\t\t\tfprintf(plot_file, '# symbol x\\n');\n\t\telseif not(isempty(strfind(LineSpec, '*')))\n\t\t\tfprintf(plot_file, '# symbol *\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'v')))\n\t\t\tfprintf(plot_file, '# symbol v\\n');\n\t\telseif not(isempty(strfind(LineSpec, '^')))\n\t\t\tfprintf(plot_file, '# symbol ^\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'o')))\n\t\t\tfprintf(plot_file, '# symbol o\\n');\n\t\telseif not(isempty(strfind(LineSpec, 's')))\n\t\t\tfprintf(plot_file, '# symbol s\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'd')))\n\t\t\tfprintf(plot_file, '# symbol d\\n');\n\t\telse\n\t\t\tfprintf(plot_file, '# symbol none\\n');\n\t\tend; %if\n\tend; %if\n\t\n\t%%%\n\t% write plot data\n\t\n\t% if X is a scalar => Y a vector\n\tif isscalar(X)\n\t\tfor i=1:length(Y)\n\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(1), Y(i), X(1), Y(i));\n\t\tend; %for\n\t% if both X and Y are vectors\n\telseif isvector(X) && isvector(Y)\n\t\tfor i=1:(length(X)-1)\n\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(i), Y(i), X(i+1), Y(i+1));\n\t\tend; %for\n\t% if X is a vector and Y a matrix\n\telseif isvector(X) && size(Y, 1) > 1 && size(Y, 2) > 1\n\t\t% rotate matrix Y to match dimensions\n\t\tif length(X) ~= size(Y, 2)\n\t\t\tY = Y';\n\t\tend;% if\n\t\tfor j=1:size(Y, 1)\n\t\t\tfor i=1:(length(X)-1)\n\t\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(i), Y(j, i), X(i+1), Y(j, i+1));\n\t\t\tend; %for\n\t\tend; %for\n\t% if X is a matrix and Y a vector\n\telseif size(X, 1) > 1 && size(X, 2) > 1 && isvector(Y)\n\t\t% rotate matrix X to match dimensions\n\t\tif size(X, 2) ~= length(Y)\n\t\t\tX = X';\n\t\tend;% if\n\t\tfor j=1:size(X, 1)\n\t\t\tfor i=1:(length(Y)-1)\n\t\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(j, i), Y(i), X(j, i+1), Y(i+1));\n\t\t\tend; %for\n\t\tend; %for\n\t% if both X and Y are matrices\n\telse % size(X, 1) > 1 && size(X, 2) > 1 && size(Y, 1) > 1 && size(Y, 2) > 1)\n\t\tfor i=1:size(X, 2)\n\t\t\tfor j=1:(size(X, 1)-1)\n\t\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(j, i), Y(j, i), X(j+1, i), Y(j+1, i));\n\t\t\tend; %for\n\t\tend; %for\n\tend; %if\n\n  %%%\n  % close file\n  fclose(plot_file);\n\t\n\t%%%\n\t% recursivly call plot to work off remaining optional arguments\n\tif size(newArgIn, 2) == 0\n\t\treturn;\n\tend; %if\n\t\n\tassert(size(newArgIn, 2) >= 2, 'Wrong number of arguments, expected more arguments.');\n\t\n\tX = newArgIn{1};\n\tY = newArgIn{2};\n\tif size(newArgIn, 2) == 2\n\t\tplot(X, Y);\n\telse\n\t\tplot(X, Y, newArgIn{3:size(newArgIn, 2)});\n\tend; %if\n\t\nend %function\n\n%%%\n% Overwrites the built-in legend function and gives out\n% a ViPLab graphic format file (.vgf).\n% It breaks with th built-in legend function because it\n% can only handly one argument. If the legend is set all\n% plots from now on will use the new legend. To stay\n% compatible with the built-in legend use legend('')\n% at the end of your program to prevent a legend.\n% \n% The argument must be a string. It does not support\n% handles, orientation or multiple legends.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-12\n%%%\n\nfunction legend(PlotLegend)\n  % ensure valid arguments\n  assert(ischar(PlotLegend), 'First argument in legend must be a string.');\n    \n\t%%%\n  % open file to append, use UTF-8 encoding\n  plot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\n\t%%%\n  % write legend data\n  fprintf(plot_file, '# legend %s\\n', PlotLegend);\n\n\t%%%\n  % close file\n  fclose(plot_file);\nend %function\n\n%%%\n% Overwrites the built-in title function and gives out\n% a ViPLab graphic format file (.vgf).\n% It behaves similar to built-in legend function and adds\n% a title to the plot.\n% \n% The arguments must be a string. No handles or properties are\n% supported.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-09\n%%%\n\nfunction title(PlotTitle, varargin)\n  % ensure valid arguments\n  assert(ischar(PlotTitle), 'First argument in title must be a string.');\n    \n\t%%%\n  % open file to append, use UTF-8 encoding\n  plot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\n\t%%%\n  % write title data\n  fprintf(plot_file, '# title %s\\n', PlotTitle);\n\n\t%%%\n  % close file\n  fclose(plot_file);\nend %function\n\n%%%\n% Overwrites the built-in plot function and gives out\n% a ViPLab graphic format file (.vgf).\n% It behaves similar to built-in plot function except\n% that complex values are forbitten and X values must\n% be provided for every plot.\n% \n% The arguments are X, Y and an optional LineSpec. These\n% two or three arguments can be appended multiple times.\n% X contains the x values of the points, Y the y values.\n% Consecutive points are drawn connected by a line.\n% X and Y must have one matching dimension if at least\n% one is a vector and must have the exact same dimension\n% if moth are matrices.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-01\n%%%\n\nfunction axis(Range)\n  xmin = Range(1);\n  xmax = Range(2);\n  ymin = Range(3);\n  ymax = Range(4);\n\t%%%\n  % ensure valid arguments\n  assert(isreal(xmin) && isreal(xmax) && isreal(ymin) && isreal(ymax), 'All arguments must be real numbers.');\n  assert(isscalar(xmin) && isscalar(xmax) && isscalar(ymin) && isscalar(ymax), 'All arguments must be scalars.');\n  assert(xmin < xmax, 'xmin must be smaller than xmax.');\n\tassert(ymin < ymax, 'ymin must be smaller than ymax.');\n\n\t%%%\n  % open file to append, use UTF-8 encoding\n  plot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\n\t%%%\n  % write axis data\n  fprintf(plot_file, '# x-range %f %f\\n', xmin, xmax);\n  fprintf(plot_file, '# y-range %f %f\\n', ymin, ymax);\n\n\t%%%\n  % close file\n  fclose(plot_file);\nend %function\n\n%%%\n% Overwrites the built-in figure function.\n% The function does nothing but surpresses the built-in\n% figure function which opens a new plot window.\n%\n% It does not accept any arguments and has no return values.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-01\n%%%\n\nfunction figure()\n  % nothing todo just prevent buit-in function to open a plot window\nend %function\n\n%%%\n% Overwrites the built-in xlabel function and gives out\n% a ViPLab graphic format file (.vgf).\n% It behaves similar to built-in xlabel function and adds\n% a label to the X-axis of the plot.\n% \n% The arguments must be a string. No handles or properties are\n% supported.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-09\n%%%\n\nfunction xlabel(AxisTitle)\n  % ensure valid arguments\n  assert(ischar(AxisTitle), 'First argument in title must be a string.');\n    \n\t%%%\n  % open file to append, use UTF-8 encoding\n  plot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\n\t%%%\n  % write title data\n  fprintf(plot_file, '# x-label %s\\n', AxisTitle);\n\n\t%%%\n  % close file\n  fclose(plot_file);\nend %function\n\n%%%\n% Overwrites the built-in ylabel function and gives out\n% a ViPLab graphic format file (.vgf).\n% It behaves similar to built-in ylabel function and adds\n% a label to the Y-axis of the plot.\n% \n% The arguments must be a string. No handles or properties are\n% supported.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-09\n%%%\n\nfunction ylabel(AxisTitle)\n  % ensure valid arguments\n  assert(ischar(AxisTitle), 'First argument in title must be a string.');\n    \n\t%%%\n  % open file to append, use UTF-8 encoding\n  plot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\n\t%%%\n  % write title data\n  fprintf(plot_file, '# y-label %s\\n', AxisTitle);\n\n\t%%%\n  % close file\n  fclose(plot_file);\nend %function\n\n%%%\n% Overwrites the built-in zlabel function and gives out\n% a ViPLab graphic format file (.vgf).\n% It behaves similar to built-in zlabel function and adds\n% a label to the Z-axis of the 3d-plot.\n% \n% The arguments must be a string. No handles or properties are\n% supported.\n%\n% Usage: Put file in the same directory containing your programm.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Grüninger (2010)\n%\n% Copyright: All rights reserved C. Grüninger 2010\n%            This function is licenced under the \n%            terms of GNU GPL 3 or higher.\n% Version: 2010-11-09\n%%%\n\nfunction zlabel(AxisTitle)\n  % ensure valid arguments\n  assert(ischar(AxisTitle), 'First argument in title must be a string.');\n    \n\t%%%\n  % open file to append, use UTF-8 encoding\n  plot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\n\t%%%\n  % write title data\n  fprintf(plot_file, '# z-label %s\\n', AxisTitle);\n\n\t%%%\n  % close file\n  fclose(plot_file);\nend %function\nfunction hold(varargin)\nend\n\n",
                  "visible": true
            },
            {
                  "MIMEtype": "text/plain",
                  "emphasis": "High",
                  "identifier": "codeFromStudent",
                  "modifiable": true,
                  "name": "",
                  "syntaxHighlighting": "Matlab",
                  "value": "% =====================================\nfunction interpolation();\n% =====================================\nfprintf('PROGRAMM START...\\n');\nclear global;\n% interpolates a function g(x) using in C=[-1;1]\n% with polynomial degree N using\nNin=5;\n% mode=1 regular grid points\n% mode=2 GLL grid points\n% mode=3 Gauss grid points\n% mode=4 'bad' grid points inside C\n% mode=5 'bad' grid points one -sided\n% mode=6 Chebyshev nodes\n% mode=7 Chebyshev Lobatto nodes\nmode=1;\n% plotmode=1 plots function and its interpolant\n% plotmode=2 additionally plots the Lagrange functions\nplotmode=1;\n\n% Print chosen parameters\nfprintf('Nin      = %d\\n',Nin);\nfprintf('mode     = %d\\n',mode);\nfprintf('plotmode = %d\\n\\n',plotmode);\n\nglobal wBary; % Barycentric weights for Lagrange interpolation \nglobal GPPos1D; % Interpolation points\nglobal N; % Polynomial degree of interpolation\n\nN=Nin; % Polynomial degree for the interpolation\n% For visualization and to determine Linf and Lebesgue constant\nNVisu=1000; % Number of sample points,\n  \n% Initialize Linf error and Lebesgue constant\nLinf=0;\nLebesgue=0;\n\n% Choose the type of interpolation points\nif (mode==1)      % Regular\n  GPPos1D = linspace(-1,1,N+1)';\nelseif (mode==2)  % Gauss Lobatto\n  [GPPos1D,GPWeight1D]=lglnodes(N);\nelseif (mode==3)  % Gauss points\n  [GPPos1D,GPWeight1D]=JacobiGQ(0,0,N);\nelseif (mode==4)  % 'bad points' inside C\n  GPPos1D = linspace(-0.5,0.5,N+1)';\nelseif (mode==5)  % 'bad points' one -sided\n  GPPos1D = linspace(-1.,0.7,N+1)';\n  GPPos1D(N+1)=1;\nelseif (mode==6)  % Chebyshev nodes\n  for j=1:N+1\n    GPPos1D(j,1) = cos((2*j-1)*pi/2/(N+1));\n  end\nelseif (mode==7)  % Chebyshev Lobatto nodes\n  for j=1:N+1\n    GPPos1D(j,1) = cos((j-1)*pi/(N));\n  end \nend\n\n% Compute barycentric weights for lagrange interpolation\n% Kopriva, Algorithm 30, pg. 75\nwBary=ones(N+1,1);\nfor j = 2:N+1\n for k = 1:j-1\n   wBary(k) = wBary(k)*(GPPos1D(k)-GPPos1D(j));\n   wBary(j) = wBary(j)*(GPPos1D(j)-GPPos1D(k));\n end\nend\nwBary = 1 ./ wBary;\n\n% Determine the position of the regular sample points\nVisuPos1D=linspace(-1,1,NVisu);\n% Evaluate all Lagrange functions at each sample point\nVisuMat=LagrangeInterpolatingPolynomials(VisuPos1D).';\n\n% Determine the nodal values of the function g(x) at the interpolation\n% points x_j\ng_j = exactfunction(GPPos1D);\n% Determine the function g(x) at the sample points \ng_exa_j=exactfunction(VisuPos1D)'; \n% Interpolate the polynomial approximation to the sample points\ng_int_j = VisuMat*g_j;\n\n% Determine the maximum value of the interpolation (for visualization)\ng_max=ceil(max(abs(g_int_j)));\n\n% Linf = max | g_exact - g_int|\nLinf = max(abs(g_int_j-g_exa_j));\n% Determine the Lebesgue constant \nfor j=1:NVisu\n    % = \\sum\\limits_j=1^(N+1) | \\psi_j(x_visu) |\n    Lebesgue_j = sum(abs(VisuMat(j,:)));\n    % Determine the maximum for all sample points\n    Lebesgue = max(Lebesgue,Lebesgue_j);\nend\n\n% Visualization of the interpolation, the exact function and the\n% interpolation grid\nif (plotmode>=1)\n  figure;\n  plot(VisuPos1D,g_int_j,'b',VisuPos1D,g_exa_j,'r',[GPPos1D';GPPos1D'],[-g_max;g_max]*ones(1,N+1),'k');\n  title('Darstellung der exakten Funktion und ihrer Interpolierenden','FontSize',14);\n  axis([-1 1 -g_max g_max])\nend\n% Plot the Lagrange functions\nif (plotmode>=2)\n    figure;\n  for j=1:N+1\n      f_j=zeros(N+1,1);\n      f_j(j)=1;\n      % Interpolate the polynomial approximation to the sample points\n      f_int_j = VisuMat*f_j;\n      g_max=ceil(max(g_max,max(abs(f_int_j))));\n      plot(VisuPos1D,f_int_j);\n      hold on;\n  end\n  % plot position of interpolation points\n  plot([GPPos1D';GPPos1D'],[-g_max;g_max]*ones(1,N+1),'k');\n  title('Darstellung der Lagrange Polynome','FontSize',14);\n  axis([-1 1 -g_max g_max])\n  hold off;  \nend\n% Print results\nfprintf('Linf     = %e\\n',Linf);\nfprintf('Lebesgue = %e\\n',Lebesgue);\nfprintf('=======================\\n');\nend\n\n% =====================================\n\n\n% =====================================\n% SUBFUNCTIONS\n% =====================================\n\n\n% =====================================\nfunction [g]=exactfunction(x);\n% =====================================\n% L_2([-1;1]) function g(x)\n\n% C_inf Function: 'leicht'\ng=sin(pi*x)+cos(pi*x);\n\n% Runge Function: 'schwer'\n%g=1./(1+(x*5).^2);\n\n% Large scale + small scale\n%g=sin(pi*x)+cos(4*pi*x)*0.01;\nend\n% =====================================\n\n\n% =====================================\nfunction [x,w]=lglnodes(N);\n% =====================================\n% Truncation + 1\nN1=N+1;\n% Use the Chebyshev-Gauss-Lobatto nodes as the first guess\nx=cos(pi*(0:N)/N)';\n% The Legendre Vandermonde Matrix\nP=zeros(N1,N1);\n% Compute P_(N) using the recursion relation\n% Compute its first and second derivatives and \n% update x using the Newton-Raphson method.\nxold=2;\nwhile max(abs(x-xold))>eps\n    xold=x;        \n    P(:,1)=1;    P(:,2)=x;    \n    for k=2:N\n        P(:,k+1)=( (2*k-1)*x.*P(:,k)-(k-1)*P(:,k-1) )/k;\n    end     \n    x=xold-( x.*P(:,N1)-P(:,N) )./( N1*P(:,N1) );             \nend\nw=2./(N*N1*P(:,N1).^2);\nend\n% =====================================\n\n\n% =====================================\nfunction [x,w] = JacobiGQ(alpha,beta,N);\n% =====================================\n% Purpose: Compute the N'th order Gauss quadrature points, x, \n%          and weights, w, associated with the Jacobi \n%          polynomial, of type (alpha,beta) > -1 ( <> -0.5).\n\nif (N==0) x(1)=(alpha-beta)/(alpha+beta+2); w(1) = 2; return; end;\n% Form symmetric matrix from recurrence.\nJ = zeros(N+1);\nh1 = 2*(0:N)+alpha+beta;\nJ = diag(-1/2*(alpha^2-beta^2)./(h1+2)./h1) + ...\n    diag(2./(h1(1:N)+2).*sqrt((1:N).*((1:N)+alpha+beta).*...\n    ((1:N)+alpha).*((1:N)+beta)./(h1(1:N)+1)./(h1(1:N)+3)),1);\nif (alpha+beta<10*eps) J(1,1)=0.0;end;\nJ = J + J';\n\n%Compute quadrature by eigenvalue solve\n[V,D] = eig(J); x = diag(D);\nw = (V(1,:)').^2*2^(alpha+beta+1)/(alpha+beta+1)*gamma(alpha+1)*...\n    gamma(beta+1)/gamma(alpha+beta+1);\nend\n% =====================================\n\n\n% =====================================\nfunction [L]=LagrangeInterpolatingPolynomials(x)\n% =====================================\n%  evaluates the lagrange basis functions at x\n%  algorithm 34, page 77\n\n% load global variables\nglobal wBary;\nglobal GPPos1D;\nglobal N;\n\n% make sure x is a row vector\nx=x(:).';\nL=zeros(N+1,length(x));\n\n% look if x is an interpolation point\nLindex=[];\nfor k=1:N+1\n  index=find(x==GPPos1D(k));\n  if (index)\n    L(k,index)=1;\n    Lindex=[Lindex,index];\n  end\nend\n\n% else compute the interpolated value of the basis functions\nLindex=setdiff(1:length(x),Lindex);\nif (Lindex)\n  s=0;\n  for k=1:N+1\n    t=wBary(k)./(x(Lindex)-GPPos1D(k));\n    L(k,Lindex)=t;\n    s=s+t;\n  end\n  L(:,Lindex)=L(:,Lindex)./s(ones(N+1,1),:);\nend\nend\n% =====================================\n\n%%%",
                  "visible": true
            }
      ],
      "identifier": "",
      "name": "[stresstest][FF] Interpolation",
      "postTime": "Do 21. Apr 18:29:38 CEST 2011"
}}