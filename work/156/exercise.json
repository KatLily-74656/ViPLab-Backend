{
  "Exercise": {
    "name": "NumSimII_Aufgabe1_Blatt2_ML_mit_Fehler",
    "config": {
      "Matlab": {
        "interpreting": {
          "flags": ""
        },
        "stopAfterPhase": "interpreting",
        "checking": {
          "allowedCalls": "abs accumarray acos acosd acosh acot acotd acoth acsc acscd acsch airy all amd and angle ans any arrayfun asec asecd asech asin asind asinh assert atan atan2 atand atanh axes axis balance besselh besseli besselj besselk bessely beta betainc betaincinv betaln bin2dec bitand bitcmp bitget bitmax bitnot bitor bitset bitshift bitxor blkdiag bvp4c bvp5c bvpget bvpinit bvpset bvpxtend cart2pol cart2sph cartToBary cast cat cdf2rdf ceil chol cholinc cholupdate circshift clear clearvars clock colamd colperm complex cond condeig condest conj conv conv2 convhull convhulln convn copy corrcoef cos cosd cosh cot cotd coth cov cplxpair cputime cross csc cscd csch ctranspose cumprod cumsum cumtrapz curl dec2base dec2bin dec2hex decic deconv del2 det detrend deval diag diff diffuse disp display divergence dmperm dot double echo eig eigs ellipj ellipke else elseif eps eq erf erfc erfcinv erfcx erfinv error exp expint expm expm1 eye factor factorial false fft fft2 fftn fftshift fftw filter filter2 find findall findstr fix flipdim fliplr flipud floor fminbnd fminsearch fprintf freqspace full function funm fzero gamma gammainc gammaincinv gammaln gcd ge getinterpmethod getsamples getsampleusingtime gettimeseriesnames gettsafteratevent gettsafterevent gettsatevent gettsbeforeatevent gettsbeforeevent gettsbetweenevents global gmres gradient grid gsvd gt gtext hadamard hankel hess hex2dec hex2num hilb horzcat hypot i ichol idealfilter idivide if ifft ifft2 ifftn ifftshift ilu imag ind2sub Inf inline int16 int2str int32 int64 int8 interp1 interp1q interp2 interp3 interpft interpn interpstreamspeed intersect intmax intmin inv invhilb ipermute iqr iscell iscellstr ischar iscolumn isempty isequal isequalwithequalnans isfield isfinite isfloat isglobal isinf isinteger isKey isletter islogical ismatrix ismember isnan isnumeric isprime isreal isrow isscalar issorted isspace issparse isstr isstrprop isstruct isvector j keys kron last lcm ldivide ldl le legend legendre length linsolve linspace log log10 log1p log2 logical logm logspace lower lscov lsqnonneg lsqr lt lu luinc magic mat2cell max mean median MException min minres minus mkpp mldivide mod mode mpower mrdivide mtimes NaN nchoosek ndgrid ne nextpow2 nnz nonzeros norm normest not nthroot null num2cell num2hex num2str numel ode113 ode15i ode15s ode23 ode23s ode23t ode23tb ode45 odefile odeget odeset odextend ones optimget optimset or ordeig orderfields ordqz ordschur orth padecoef parfor pascal pcg pchip pcode pdepe pdeval perms permute persistent pi pinv planerot plot plus pol2cart poly polyarea polyder polyeig polyfit polyint polyval polyvalm pow2 power ppval primes prod psi qmr qr qrdelete qrinsert qrupdate quad quad2d quadgk quadl quadv qz rand randi randn randperm rank rat rats rcond rdivide real reallog realmax realmin realpow realsqrt regexp regexpi regexprep regexptranslate rem repmat resample reshape residue rng roots rot90 round rref rsf2csf schur sec secd sech set setdiff setfield setinterpmethod settimeseriesnames setuniformtime setxor shiftdim sign sin sind single sinh size sort sortrows spalloc sparse spaugment spconvert spdiags speye spfun sph2cart spline spones spparms sprand sprandn sprandsym sprank sprintf sqrt sqrtm squeeze ss2tf sscanf std str2double str2mat str2num strcat strcmp strcmpi strfind strings strjust strmatch strncmp strncmpi strread strrep strtok strtrim struct struct2cell structfun strvcat sub2ind subsasgn subsindex subspace subsref substruct subvolume sum svd svds swapbytes symamd symbfact symmlq symrcm symvar synchronize tan tand tanh tfqmr times timeseries title toeplitz trace transpose trapz tril triu true tscollection tsearchn typecast uint16 uint32 uint64 uint8 uminus unicode2native union unique unmesh unmkpp uplus upper validateattributes validatestring values vander var varargin varargout vectorize vertcat while wilkinson xlabel xlim xor ylabel ylim zeros zlabel zlim",
          "sources": [
            "Id1"
          ]
        },
        "merging": {
          "sources": [
            "Id1",
            "Id3"
          ]
        }
      }
    },
    "postTime": "Fri Nov 18 14:57:50 CET 2011",
    "elements": [
      {
        "modifiable": true,
        "MIMEtype": "text/plain",
        "syntaxHighlighting": "Matlab",
        "value": "function Aufgabe_1_Blatt_2()\n\n  dx = 0.1;\n  dy = 0.1;\n\n  nx = 1 / dx - 1;\n  ny = 1 / dy - 1;\n\n  % Matrizen definieren\n  x=zeros(nx,1);\n  y=zeros(ny,1);\n  A=zeros(nx*ny,nx*ny);\n  r=zeros(nx*ny,1);\n\n  % Gitterpositionen festlegen\n  for i=1:nx\n    x(i,1) = dx*i;\n  end\n\n  for j=1:ny\n    y(j,1) = dx*j;\n  end\n\n  % Matrizen befuellen\n  for j=1:ny\n    for i=1:nx\n\n\n\n      r(i+(j-1)*nx,1) = f(x(i,1),y(j,1));\n\n      % Anteil des Elements selbst\n      A(i+(j-1)*nx,i+(j-1)*nx) = -2/dx^2-2/dy^2;\n\n      % rechter Nachbar\n      if i < nx\n        A(i+(j-1)*nx,i+1+(j-1)*nx) = 1/dx^2;\n      else\n        r(i+(j-1)*nx,1) = r(i+(j-1)*nx,1)-1/dx^2*g(x(i,1)+dx,y(j,1));\n      end\n\n      % linker Nachbar\n      if i > 1 \n        A(i+(j-1)*nx,i-1+(j-1)*nx) = 1/dx^2;\n      else\n        r(i+(j-1)*nx,1) = r(i+(j-1)*nx,1)-1/dx^2*g(x(i,1)-dx,y(j,1));\n      end\n\n      % oberer Nachbar\n      if j < ny \n        A(i+(j-1)*nx,i+j*nx) = 1/dy^2;\n      else\n        r(i+(j-1)*nx,1) = r(i+(j-1)*nx,1)-1/dy^2*g(x(i,1),y(j,1)+dy);\n      end\n\n      % unterer Nachbar\n      if j > 1 \n        A(i+(j-1)*nx,i+(j-2)*nx) = 1/dy^2;\n      else\n        r(i+(j-1)*nx,1) = r(i+(j-1)*nx,1)-1/dy^2*g(x(i,1),y(j,1)-dy);\n      end\n    end\n  end\n\n  % LGS loesen\n  u=GaussSeidel(A,r,nx,ny);\n\n  % Loesung ausgeben\n  visualize(u,nx,ny,dx,dy);\n\nend\n\n\nfunction u=GaussSeidel(A,r,nx,ny)\n\n  % Konstanten definieren\n  iter = 0;\n  maxiter = 10000;\n  eps = 1e-8;\n  res = 2*eps;\n  \n  % Matrizen vorbereiten\n  u=zeros(nx*ny,1);\n  utilde=zeros(nx*ny,1);\n\n  % Iterationsschleife, bis Abbruchbedingung erfuellt\n  while iter<maxiter & res>eps\n    iter = iter + 1;\n\n    for i=1:nx*ny\n      utilde(i,1)=r(i,1);\n      for j=1:i-1\n        utilde(i,1)=utilde(i,1)-A(i,j)*utilde(j,1);\n      end\n      for j=i+1:nx*ny\n        utilde(i,1)=utilde(i,1)-A(i,j)*u(j,1);\n      end\n      utilde(i,1)=utilde(i,1)/A(i,i);\n    end\n    u = utilde;\n    \n    % Residuum berechnen\n    res=max(abs(A*u-r));\n  end\n \nend\n\n\nfunction f=f(x,y)\n  f=sin(pi*x)*sin(pi*y);\nend\n\nfunction g=g(x,y)\n  >+0.02*x+0.05*y;\nend\n",
        "emphasis": "High",
        "identifier": "Id1",
        "visible": true
      },
      {
        "modifiable": false,
        "MIMEtype": "text/plain",
        "syntaxHighlighting": "Matlab",
        "value": "function [uexakt,xout,yout]=func_uexakt(dx,dy,nx,ny)\n\n  xout=zeros(nx+2,1);\n  yout=zeros(ny+2,1);\n  uexakt=zeros(ny+2,nx+2);\n  \n  for i=1:nx+2\n    xout(i,1) = dx*(i-1);\n  end\n\n  for j=1:ny+2\n    yout(j,1) = dy*(j-1);\n  end\n\n  for j=1:ny+2\n    for i=1:nx+2\n      uexakt(j,i) = -1/(2*pi^2)*sin(pi*xout(i,1))*...\n            sin(pi*yout(j,1))+0.02*xout(i,1)+0.05*yout(j,1)+1;\n    end\n  end\n\nend\n\nfunction visualize(u,nx,ny,dx,dy)\n\n  nLevels = 21;\n\n  [uexakt,xout,yout]=func_uexakt(dx,dy,nx,ny);\n\n  uout=zeros(ny+2,nx+2);\n  uout = uexakt;\n  uout(2:ny+1,2:nx+1) = transpose(reshape(u,nx,ny));\n  \n  minval=min(min(min(uout)),min(min(uexakt)));\n  maxval=max(max(max(uout)),max(max(uexakt)));\n\n  figure();\n  [xplot,yplot,typeplot,lineLengthTotal,levelValue]=createIsoLines(xout,yout,uout,minval,maxval,nLevels);\n  plotIsolines(xplot,yplot,typeplot,lineLengthTotal);\n  title('u');\n  xlabel('x');\n  ylabel('y');\n  \n  figure();\n  [xplot,yplot,typeplot,lineLengthTotal,levelValue]=createIsoLines(xout,yout,uexakt,minval,maxval,nLevels);\n  plotIsolines(xplot,yplot,typeplot,lineLengthTotal);\n  title('u_exakt');\n  xlabel('x');\n  ylabel('y');\nend\n\nfunction [xplot,yplot,typeplot,lineLengthTotal,levelValue]=createIsoLines(x,y,uin,minval,maxval,nLevels)\n\n  u=zeros(size(uin,1),size(uin,2),2);\n  u(:,:,1) = uin;\n  u(:,:,2) = uin;\n\n  nLinesTotal=0;\n  levelValue=zeros(nLevels,1);\n  maxLineLength=0;\n\n  for iLevel=1:nLevels\n    levelValue(iLevel,1)=minval+iLevel*(maxval-minval)/(nLevels+1);\n    [f,v]=isosurface(x,y,[0 1],u,levelValue(iLevel,1));\n\n    f=f(find(sum(reshape(v(f,3),size(f)),2)==1),:);\n    f=f.*reshape(1-v(f,3),size(f));\n    f=sort(f,2);\n    f=f(:,2:3);\n\n    n=size(f,1);\n    lineEnd = zeros(n,1);\n\n    nLines=0;\n    i=1;\n    currentstart=f(i,1);\n    while i<n\n      if any(any(f(i+1:n,:)==f(i,2)))\n        for j=i+1:n\n          if any(f(j,:)==f(i,2))\n            rdummy = f(j,:);\n            if f(j,1)==f(i,2)\n              f(j,:)=f(i+1,:);\n              f(i+1,:)=rdummy;\n            else\n              f(j,:)=f(i+1,:);\n              f(i+1,2)=rdummy(1,1);\n              f(i+1,1)=rdummy(1,2);\n            end\n            if f(i+1,2)==currentstart\n              nLines=nLines+1;\n              lineEnd(nLines,1) = i+1;\n              currentstart=f(min(i+2,n),1);\n              i=i+2;\n            else\n              i=i+1;\n            end\n            break\n          end\n        end\n      else\n        nLines=nLines+1;\n        lineEnd(nLines,1) = i;\n        currentstart=f(i+1,1);\n        i=i+1;\n      end\n    end\n    if i==n\n      nLines=nLines+1;\n      lineEnd(nLines,1) = i;\n    end\n\n    if lineEnd(nLines)~=n\n      nLines=nLines+1;\n      lineEnd(nLines,1) = n;\n    end\n\n    lineEnd = lineEnd(1:nLines,1);\n\n    lineLength=zeros(nLines,1);\n    lineLength(1,1) = lineEnd(1,1)+1;\n    lineLength(2:nLines,1) = lineEnd(2:nLines)-lineEnd(1:nLines-1)+1;\n\n    points = zeros(nLines,n);\n    for i=1:nLines\n      points(i,1:lineLength(i,1)-1) = f(lineEnd(i,1)-lineLength(i,1)+2:lineEnd(i,1),1);\n      points(i,lineLength(i,1)) = f(lineEnd(i,1),2);\n    end\n\n    for h=1:nLines\n      for i=1:nLines\n        for j=i+1:nLines\n          if points(i,1)==points(j,1) & points(i,1)~=0;\n            points(i,lineLength(j,1):lineLength(i,1)+lineLength(j,1)-1)=points(i,1:lineLength(i,1));\n            for k=1:lineLength(j,1)-1\n              points(i,k)=points(j,lineLength(j,1)-k+1);\n            end\n            points(j,:)=0;\n            lineLength(i,1)=lineLength(i,1)+lineLength(j,1)-1;\n            lineLength(j,1)=0;\n          end\n          if(lineLength(j,1)>0)\n            if points(i,1)==points(j,lineLength(j,1)) & points(i,1)~=0;\n              points(i,lineLength(j,1):lineLength(i,1)+lineLength(j,1)-1)=points(i,1:lineLength(i,1));\n              points(i,1:lineLength(j,1)-1)=points(j,1:lineLength(j,1)-1);\n              points(j,:)=0;\n              lineLength(i,1)=lineLength(i,1)+lineLength(j,1)-1;\n              lineLength(j,1)=0;\n            end\n          end\n        end\n      end\n    end\n\n    points=sortrows(points,-1);\n    nLines=size(find(points(:,1)~=0),1);\n\n    nLinesTotal=nLinesTotal+nLines;\n    maxLineLength=max(maxLineLength,max(lineLength));\n  end\n\n  xplot=zeros(nLinesTotal,maxLineLength);\n  yplot=zeros(nLinesTotal,maxLineLength);\n  typeplot=zeros(nLinesTotal,1);\n  lineLengthTotal=zeros(nLinesTotal,1);\n\n  nLinesTotal=0;\n  for iLevel=1:nLevels\n    [f,v]=isosurface(x,y,[0 1],u,levelValue(iLevel,1));\n\n    f=f(find(sum(reshape(v(f,3),size(f)),2)==1),:);\n    f=f.*reshape(1-v(f,3),size(f));\n    f=sort(f,2);\n    f=f(:,2:3);\n\n    n=size(f,1);\n    lineEnd = zeros(n,1);\n\n    nLines=0;\n    i=1;\n    currentstart=f(i,1);\n    while i<n\n      if any(any(f(i+1:n,:)==f(i,2)))\n        for j=i+1:n\n          if any(f(j,:)==f(i,2))\n            rdummy = f(j,:);\n            if f(j,1)==f(i,2)\n              f(j,:)=f(i+1,:);\n              f(i+1,:)=rdummy;\n            else\n              f(j,:)=f(i+1,:);\n              f(i+1,2)=rdummy(1,1);\n              f(i+1,1)=rdummy(1,2);\n            end\n            if f(i+1,2)==currentstart\n              nLines=nLines+1;\n              lineEnd(nLines,1) = i+1;\n              currentstart=f(min(i+2,n),1);\n              i=i+2;\n            else\n              i=i+1;\n            end\n            break\n          end\n        end\n      else\n        nLines=nLines+1;\n        lineEnd(nLines,1) = i;\n        currentstart=f(i+1,1);\n        i=i+1;\n      end\n    end\n    if i==n\n      nLines=nLines+1;\n      lineEnd(nLines,1) = i;\n    end\n\n    if lineEnd(nLines)~=n\n      nLines=nLines+1;\n      lineEnd(nLines,1) = n;\n    end\n\n    lineEnd = lineEnd(1:nLines,1);\n\n    lineLength=zeros(nLines,1);\n    lineLength(1,1) = lineEnd(1,1)+1;\n    lineLength(2:nLines,1) = lineEnd(2:nLines)-lineEnd(1:nLines-1)+1;\n\n    points = zeros(nLines,n);\n    for i=1:nLines\n      points(i,1:lineLength(i,1)-1) = f(lineEnd(i,1)-lineLength(i,1)+2:lineEnd(i,1),1);\n      points(i,lineLength(i,1)) = f(lineEnd(i,1),2);\n    end\n\n    for h=1:nLines\n      for i=1:nLines\n        for j=i+1:nLines\n          if points(i,1)==points(j,1) & points(i,1)~=0;\n            points(i,lineLength(j,1):lineLength(i,1)+lineLength(j,1)-1)=points(i,1:lineLength(i,1));\n            for k=1:lineLength(j,1)-1\n              points(i,k)=points(j,lineLength(j,1)-k+1);\n            end\n            points(j,:)=0;\n            lineLength(i,1)=lineLength(i,1)+lineLength(j,1)-1;\n            lineLength(j,1)=0;\n          end\n          if(lineLength(j,1)>0)\n            if points(i,1)==points(j,lineLength(j,1)) & points(i,1)~=0;\n              points(i,lineLength(j,1):lineLength(i,1)+lineLength(j,1)-1)=points(i,1:lineLength(i,1));\n              points(i,1:lineLength(j,1)-1)=points(j,1:lineLength(j,1)-1);\n              points(j,:)=0;\n              lineLength(i,1)=lineLength(i,1)+lineLength(j,1)-1;\n              lineLength(j,1)=0;\n            end\n          end\n        end\n      end\n    end\n\n    points=sortrows(points,-1);\n    nLines=size(find(points(:,1)~=0),1);\n    points=points(1:nLines,1:max(lineLength));\n    lineLength=0;\n\n    for i=1:nLines\n      lineLength=size(find(points(i,:)~=0),2);\n      xplot(nLinesTotal+i,1:lineLength)=v(points(i,1:lineLength),1);\n      yplot(nLinesTotal+i,1:lineLength)=v(points(i,1:lineLength),2);\n      typeplot(nLinesTotal+i,1)=iLevel;\n      lineLengthTotal(nLinesTotal+i,1)=lineLength;\n    end\n    nLinesTotal=nLinesTotal+nLines;\n\n  end\n  clear f v points lineEnd lineLength;\n\nend\n\nfunction plotIsolines(xplot,yplot,typeplot,lineLengthTotal)\n\n  nLinesTotal=size(xplot,1);\n\n  for i=1:nLinesTotal\n    switch typeplot(i,1)\n      case 1\n        plot(xplot(i,1:lineLengthTotal(i,1)),yplot(i,1:lineLengthTotal(i,1)),'-c');\n      case 6\n        plot(xplot(i,1:lineLengthTotal(i,1)),yplot(i,1:lineLengthTotal(i,1)),'-m');\n      case 11\n        plot(xplot(i,1:lineLengthTotal(i,1)),yplot(i,1:lineLengthTotal(i,1)),'-r');\n      case 16\n        plot(xplot(i,1:lineLengthTotal(i,1)),yplot(i,1:lineLengthTotal(i,1)),'-g');\n      case 21\n        plot(xplot(i,1:lineLengthTotal(i,1)),yplot(i,1:lineLengthTotal(i,1)),'-b');\n      otherwise\n        plot(xplot(i,1:lineLengthTotal(i,1)),yplot(i,1:lineLengthTotal(i,1)),':k');\n    end      \n    hold on;\n  end\n  hold off;\n\nend\n\n\n%%%\n% Overwrites the built-in plot functions and gives out\n% a ViPLab graphic format file (.vgf).\n%\n% Usage: Paste this file in the same file below your program. Be\n%        aware of using \"end\" for every of your functions.\n%        Matlab will warn you that it may conflict with built-in\n%        functions but that is intended.\n%\n% Author: C. Gr\u00fcninger (2010 - 2011)\n%\n% Copyright: All rights reserved C. Gr\u00fcninger 2010 - 2011\n%            This functions are licenced under the terms\n%            of GNU GPL 3 or higher.\n% Version: 2011-07-13\n%%%\n\n\n%%%\n% It behaves similar to built-in plot function except\n% that complex values are forbitten and X values must\n% be provided for every plot.\n% \n% The arguments are X, Y and an optional LineSpec. These\n% two or three arguments can be appended multiple times.\n% X contains the x-values of the points, Y the y-values.\n% Consecutive points are drawn connected by a line.\n% X and Y must have one matching dimension if at least\n% one is a vector and must have the exact same dimension\n% if both are matrices.\nfunction plot(X, Y, varargin)\n\t% ensure valid arguments\n\tassert(not(isempty(X)), 'X must not be empty.');\n\tassert(not(isempty(Y)), 'Y must not be empty.');\n\tassert(isnumeric(X), 'X must be numeric.');\n\tassert(isnumeric(Y), 'Y must be numeric.');\n\tassert(not(isscalar(X)) || isvector(Y), 'If X is scalar Y must be a vector.');\n\tassert(not(isvector(X) && not(isscalar(X)) && isvector(Y)) || (length(X) == length(Y)), 'Vectors X and Y must have same dimensions.');\n\tassert(not(isvector(X) && not(isscalar(X)) && size(Y, 1) > 1 && size(Y, 2) > 1) || (length(X) == size(Y, 1) || length(X) == size(Y, 2)), 'Vector X and matrix Y must have one dimension in common.');\n\tassert(not(size(X, 1) > 1 && size(X, 2) > 1 && isvector(Y)) || (size(X, 1) == length(Y) || size(X, 2) == length(Y)), 'Matrix X and vector Y must have one dimension in common.');\n\tassert(not(size(X, 1) > 1 && size(X, 2) > 1 && size(Y, 1) > 1 && size(Y, 2) > 1) || isequal(size(X),size(Y)), 'Matrices X and Y must have same dimensions.');\n\t\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% handle optional arguments\n\tLineSpec = 'b-';\n\tnewArgIn = {};\n\t% if first optional argument is a string, it's the line specification\n\tif (size(varargin, 2) == 1) && ischar(varargin{1})\n\t\tLineSpec = varargin{1};\n\t% pass remaining optional arguments to next plot call\n\telseif (size(varargin, 2) > 1) && ischar(varargin{1})\n\t\tLineSpec = varargin{1};\n\t\tnewArgIn = varargin(2:size(varargin, 2));\n\telseif (size(varargin, 2) > 0)\n\t\tnewArgIn = varargin;\n\tend; %if\n\n\t%%%\n\t% write symbol, linestyle and color data\n\tif not(isempty(LineSpec))\n\t\t% write color data\n\t\tif not(isempty(strfind(LineSpec, 'r')))\n\t\t\tfprintf(plot_file, '# color 255 0 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'b')))\n\t\t\tfprintf(plot_file, '# color 0 0 255\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'g')))\n\t\t\tfprintf(plot_file, '# color 0 255 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'c')))\n\t\t\tfprintf(plot_file, '# color 0 255 255\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'm')))\n\t\t\tfprintf(plot_file, '# color 255 0 255\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'y')))\n\t\t\tfprintf(plot_file, '# color 255 255 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'k')))\n\t\t\tfprintf(plot_file, '# color 0 0 0\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'w')))\n\t\t\tfprintf(plot_file, '# color 255 255 255\\n');\n\t\telse\n\t\t\tfprintf(plot_file, '# color 0 0 0\\n');\n\t\tend; %if\n\t\t\n\t\t% write symbol data\n\t\tnoSymbolGiven = false;\n\t\tif not(isempty(strfind(LineSpec, 'x')))\n\t\t\tfprintf(plot_file, '# symbol x\\n');\n\t\telseif not(isempty(strfind(LineSpec, '*')))\n\t\t\tfprintf(plot_file, '# symbol *\\n');\n\t\telseif not(isempty(strfind(LineSpec, '.')))\n\t\t\tfprintf(plot_file, '# symbol .\\n');\n\t\telseif not(isempty(strfind(LineSpec, '+')))\n\t\t\tfprintf(plot_file, '# symbol +\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'v')))\n\t\t\tfprintf(plot_file, '# symbol v\\n');\n\t\telseif not(isempty(strfind(LineSpec, '^')))\n\t\t\tfprintf(plot_file, '# symbol ^\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'o')))\n\t\t\tfprintf(plot_file, '# symbol o\\n');\n\t\telseif not(isempty(strfind(LineSpec, 's')))\n\t\t\tfprintf(plot_file, '# symbol s\\n');\n\t\telseif not(isempty(strfind(LineSpec, 'd')))\n\t\t\tfprintf(plot_file, '# symbol d\\n');\n\t\telseif and(not(isempty(strfind(LineSpec, '.'))), isempty(strfind(LineSpec, '-.')))\n\t\t\tfprintf(plot_file, '# symbol .\\n');\n\t\telse\n\t\t\tfprintf(plot_file, '# symbol none\\n');\n\t\t\tnoSymbolGiven = true;\n\t\tend; %if\n\t\t\n\t\t% write line style data\n\t\tif not(isempty(strfind(LineSpec, '--')))\n\t\t\tfprintf(plot_file, '# linestyle dashed\\n');\n\t\telseif not(isempty(strfind(LineSpec, '-.')))\n\t\t\tfprintf(plot_file, '# linestyle dash-dot\\n');\n\t\telseif not(isempty(strfind(LineSpec, ':')))\n\t\t\tfprintf(plot_file, '# linestyle dotted\\n');\n\t\telseif not(isempty(strfind(LineSpec, '-')))\n\t\t\tfprintf(plot_file, '# linestyle solid\\n');\n\t\telse\n\t\t\t% if no symbol is given the line must be solid\n\t\t\tif noSymbolGiven\n\t\t\t\tfprintf(plot_file, '# linestyle solid\\n');\n\t\t\telse\n\t\t\t\tfprintf(plot_file, '# linestyle none\\n');\n\t\t\tend; %if\n\t\tend; %if\n\tend; %if\n\t\n\t%%%\n\t% write plot data\n\t\n\t% if X is a scalar => Y a vector\n\tif isscalar(X)\n\t\tfor i=1:length(Y)\n\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(1), Y(i), X(1), Y(i));\n\t\tend; %for\n\t% if both X and Y are vectors\n\telseif isvector(X) && isvector(Y)\n\t\tfor i=1:(length(X)-1)\n\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(i), Y(i), X(i+1), Y(i+1));\n\t\tend; %for\n\t% if X is a vector and Y a matrix\n\telseif isvector(X) && size(Y, 1) > 1 && size(Y, 2) > 1\n\t\t% rotate matrix Y to match dimensions\n\t\tif length(X) ~= size(Y, 2)\n\t\t\tY = Y';\n\t\tend;% if\n\t\tfor j=1:size(Y, 1)\n\t\t\tfor i=1:(length(X)-1)\n\t\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(i), Y(j, i), X(i+1), Y(j, i+1));\n\t\t\tend; %for\n\t\tend; %for\n\t% if X is a matrix and Y a vector\n\telseif size(X, 1) > 1 && size(X, 2) > 1 && isvector(Y)\n\t\t% rotate matrix X to match dimensions\n\t\tif size(X, 2) ~= length(Y)\n\t\t\tX = X';\n\t\tend;% if\n\t\tfor j=1:size(X, 1)\n\t\t\tfor i=1:(length(Y)-1)\n\t\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(j, i), Y(i), X(j, i+1), Y(i+1));\n\t\t\tend; %for\n\t\tend; %for\n\t% if both X and Y are matrices\n\telse % size(X, 1) > 1 && size(X, 2) > 1 && size(Y, 1) > 1 && size(Y, 2) > 1)\n\t\tfor i=1:size(X, 2)\n\t\t\tfor j=1:(size(X, 1)-1)\n\t\t\t\tfprintf(plot_file, '%f %f %f %f\\n', X(j, i), Y(j, i), X(j+1, i), Y(j+1, i));\n\t\t\tend; %for\n\t\tend; %for\n\tend; %if\n\t\n\t% close file\n\tfclose(plot_file);\n\t\n\t%%%\n\t% recursivly call plot to work off remaining optional arguments\n\tif size(newArgIn, 2) == 0\n\t\treturn;\n\tend; %if\n\t\n\tassert(size(newArgIn, 2) >= 2, 'Wrong number of arguments, expected more arguments.');\n\t\n\tplot(newArgIn{1:size(newArgIn, 2)});\nend %function\n\n%%%\n% Plots with two logarithmic scales.\n% Only positive numbers are allowed to be plotted.\n%%%\nfunction loglog(X, Y, varargin)\n\t% ensure valid arguments\n\t% no error but ignore complete loglog call if non-positive numbers found\n\tif (and(min(min(X)) > 0.0, min(min(Y)) > 0.0))\n\t\tplot(X, Y, varargin{:});\n\t\t\n\t\t% open file to append\n\t\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\t\n\t\t% write loglog mode\n\t\tfprintf(plot_file, '# scale log-log\\n');\n\t\t\n\t\t% close file\n\t\tfclose(plot_file);\n\tend; %if\nend %function\n\n%%%\n% Plots with logarithmic scale for x.\n% Only positive arguments are allowed to be plotted for x-values.\n%%%\nfunction semilogx(X, Y, varargin)\n\t% ensure valid arguments\n\t% no error but ignore complet loglog call if non-positive numbers found\n\tif (min(min(X)) > 0.0)\n\t\tplot(X, Y, varargin{:});\n\t\t% open file to append\n\t\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\t\n\t\t% write loglog mode\n\t\tfprintf(plot_file, '# scale log-lin\\n');\n\t\t\n\t\t% close file\n\t\tfclose(plot_file);\n\tend; %if\nend %functions\n\n%%%\n% Plots with logarithmic scale for y.\n% Only positive arguments are allowed to be plotted for y-values.\n%%%\nfunction semilogy(X, Y, varargin)\n\t% ensure valid arguments\n\t% no error but ignore complet loglog call if non-positive numbers found\n\tif (min(min(Y)) > 0.0)\n\t\tplot(X, Y, varargin{:});\n\t\t% open file to append\n\t\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\t\n\t\t% write loglog mode\n\t\tfprintf(plot_file, '# scale lin-log\\n');\n\t\t\n\t\t% close file\n\t\tfclose(plot_file);\n\tend; %if\nend %function\n\n%%%\n% Surpress built-in hold funtion.\n%%%\nfunction hold(varargin)\n\t% do nothing\nend %function\n\n%%%\n% Set plot legend. To stay compatible write all legends \n% after plotting.\n% \n% The arguments must be strings. It does not support\n% handles or orientation.\n%%%\nfunction legend(varargin)\n\t% ensure valid arguments\n\tfor k = 1:size(varargin, 2);\n\t\tassert(ischar(varargin{k}), sprintf('%i All arguments in legend must be strings.', k));\n\tend; %for\n\t\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% write legend data\n\tfprintf(plot_file, '# legend ');\n\tfor k = 1:(size(varargin, 2) - 1);\n\t\tfprintf(plot_file, '%s,', varargin{k});\n\tend; %for\n\tfprintf(plot_file, '%s\\n', varargin{size(varargin, 2)});\n\t\n\t% close file\n\tfclose(plot_file);\nend %function\n\n%%%\n% Adds the title to the plot.\n% \n% The arguments must be a string. No handles or properties are\n% supported.\n%%%\nfunction title(PlotTitle, varargin)\n\t% ensure valid arguments\n\tassert(ischar(PlotTitle), 'First argument in title must be a string.');\n\t\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% write title data\n\tfprintf(plot_file, '# title %s\\n', PlotTitle);\n\t\n\t% close file\n\tfclose(plot_file);\nend %function\n\n%%%\n% Set x-range of visible part of the plot.\n%%%\nfunction xlim(xmin, xmax, varargin)\n\t% ensure valid arguments\n\tassert(isreal(xmin) && isreal(xmax), 'All arguments must be real numbers.');\n\tassert(isscalar(xmin) && isscalar(xmax), 'All arguments must be scalars.');\n\tassert(xmin < xmax, 'xmin must be smaller than xmax.');\n\t\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% write axis data\n\tfprintf(plot_file, '# x-range %f %f\\n', xmin, xmax);\n\t\n\t% close file\n\tfclose(plot_file);\nend %function\n\n%%%\n% Set y-range of visible part of the plot.\n%%%\nfunction ylim(ymin, ymax, varargin)\n\t% ensure valid arguments\n\tassert(isreal(ymin) && isreal(ymax), 'All arguments must be real numbers.');\n\tassert(isscalar(ymin) && isscalar(ymax), 'All arguments must be scalars.');\n\tassert(ymin < ymax, 'ymin must be smaller than ymax.');\n\t\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% write axis data\n\tfprintf(plot_file, '# y-range %f %f\\n', ymin, ymax);\n\t\n\t% close file\n\tfclose(plot_file);\nend %function\n\n%%%\n% Adds a new plot frame.\n%%%\nfunction figure(varargin)\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% write command\n\tfprintf(plot_file, '# newframe\\n');\n\t\n\t% close file\n\tfclose(plot_file);\nend %function\n\n%%%\n% Add a label to the X-axis of the plot.\n% \n% The arguments must be a string. No handles or properties are\n% supported.\n%%%\nfunction xlabel(AxisTitle, varargin)\n\t% ensure valid arguments\n\tassert(ischar(AxisTitle), 'First argument in title must be a string.');\n\t\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% write title data\n\tfprintf(plot_file, '# x-label %s\\n', AxisTitle);\n\t\n\t% close file\n\tfclose(plot_file);\nend %function\n\n%%%\n% Add a label to the Y-axis of the plot.\n% \n% The arguments must be a string. No handles or properties are\n% supported.\n%%%\nfunction ylabel(AxisTitle, varargin)\n\t% ensure valid arguments\n\tassert(ischar(AxisTitle), 'First argument in title must be a string.');\n\t\n\t% open file to append\n\tplot_file = fopen('vipplot.vgf', 'a');%, 'n', 'UTF-8');\n\t\n\t% write title data\n\tfprintf(plot_file, '# y-label %s\\n', AxisTitle);\n\t\n\t% close file\n\tfclose(plot_file);\nend %function\n",
        "emphasis": "Low",
        "identifier": "Id3",
        "visible": false
      }
    ],
    "description": "NumSimII_Aufgabe1_Blatt2_ML",
    "identifier": "Id:-1509083584",
    "department": "RUS"
  }
}
