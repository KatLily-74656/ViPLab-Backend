import os, subprocess, dataObjects, json, signal
#sys import to put temp dir relative to main.py
#can be removed when that's a fixed absolute path
import sys
from pycparser import c_parser, c_ast, parse_file

# Path for temp files.
PATH = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), "temp")
# Keeps files created in temp folder if DEBUG = True
DEBUG = True

class C:
    """ Class for processing, compiling, running and evaluating C code.

    Attributes:
        solution (Solution):
            Solution object storing data from solution json and the corresponding exercise object
        result (Result):
            Result object storing evaluation data generated by this class.
    """
    def __del__(self):
        """ Destructor deletes files in temp folder after execution 
        """
        if os.path.isdir(PATH) and not DEBUG:
            for f in os.scandir(PATH):
                os.remove(f.path)
            print("temp folder cleared")

    def __init__(self, solution : dataObjects.Solution, config : dict = None, id : int = None):
        """ Constructor

        Args:
            solution (Solution):
                The solution object storing data from solution json and exercise object
        """
        self.result = dataObjects.Result(dataObjects.readJson(solution.createJson()))
        self.solution = solution
        self.cfg = {} if config is None else config
        self._lang = self.solution.exercise.lang
        self._fileext = "c" if self._lang == "C" else "cpp"
        if id is not None:
            self.result.setId(id)

    def processData(self):
        """ Processes code, generates files and runs them to get a result.
        """
        # Creates temp dir if it does not exist
        if not os.path.exists(PATH):
            os.makedirs(PATH)
            print("created temp folder")

        # Prepare code by replacing placeholder code with solutions code
        self.replaceCodeWithSolution()

        maxState = self.getMaxState()
        # Step 1: Merge source code
        exitcode, self.fileInfo = self.merge()
        #print(f"fileInfo:\n{json.dumps(self.fileInfo, indent = 2)}")
        # Step 2: Compile files containing source code
        if exitcode == 0 and 1 <= maxState:
            exitcode = self.compile()
        # Step 3 (Only C): Check if student's solution contains illegal calls
        if exitcode == 0 and 2 <= maxState and self._lang == "C":
            exitcode = self.check()
        # Step 4: Link compiled files and libraries
        if exitcode == 0 and 3 <= maxState:
            exitcode = self.link()
        # Step 5: Run exectutable files
        if exitcode == 0 and 4 <= maxState:
            self.run()

        # Calculating computation time in result object
        self.result.calculateComputationTime()

    def getMaxState(self) -> int:
        """ Retrieves max state of data processing 

        Returns:
            An integer representing the max state 
        """
        s = self.solution.exercise.config.get("stopAfterPhase")
        return 4 if s is None or s == "running" else \
            3 if s == "linking" else \
            2 if s == "checking" else \
            1 if s == "compiling" else 0
    
    def replaceCodeWithSolution(self):
        """ Modifying exercise code by replacing placeholder code with student solution
        """
        for sEl in self.solution.exerciseModifications["elements"]:
            for eEl in self.solution.exercise.elements:
                if eEl["identifier"] == sEl["identifier"] and eEl.get("modifiable") == True:
                    eEl["value"] = sEl["value"]
                    break

    def merge(self):
        """ Merges all code snippets given by exercise json in config.merging

        Returns:
            A dict containing one dict per merged source file.
                - key: filename (without extension)
                - value: dict
            The structure of each of these dicts describing source files:
                - key: identifier of code snippet
                - value: dict containing following (keys: values):
                    - "visible": Bool indicating if section is visible for student
                    - "start": Integer indicating Start of Section (line number)
                    - "stop": Integer indicating End of Section (line number)
        """
        l = len(self.solution.exercise.config["merging"])
        if l == 0:
            self.result.computation["userInfo"]["summary"] = "[ERROR]"
            self.result.computation["userInfo"]["elements"] = [{
                "severity": "error",
                "type": "chain",
                "message": "Merging failed! Empty merging array"
            }]
            return 1, {}
        elif l == 1:
            return 0, self.mergeSingleFile()
        else:
            return 0, self.mergeMultipleFiles()

    def mergeSingleFile(self) -> dict:
        """ Merges a single file.

        Returns:
            A dict as specified as in "merge".
            The filename is always "temp"
        """
        r = {"temp" : {}}
        code = ""
        loc = 0
        for s in self.solution.exercise.config["merging"]["sources"]:
            for e in self.solution.exercise.elements:
                if s == e["identifier"]:
                    r["temp"][s] = {}
                    if e.get("visible") is not None:
                        r["temp"][s]["visible"] = e["visible"]
                    r["temp"][s]["start"] = (loc + 1)
                    code += e["value"]
                    if not code.endswith("\n"):
                        code += "\n"
                    cnt = e["value"].count("\n")
                    loc += cnt
                    r["temp"][s]["stop"] = loc if cnt != 0 else (loc + 1)
                    break
        loc += 1
        with open(os.path.join(PATH, f"temp.{self._fileext}"), "w+") as f:
            f.write(code)
        os.chmod(os.path.join(PATH, f"temp.{self._fileext}"), 0o666)
        return r

    def mergeMultipleFiles(self) -> dict:
        """ Merges multiple files.

        Returns:
            A dict as specified as in "merge".
        """
        r = {}
        for m in self.solution.exercise.config["merging"]:
            fname = m["mergeID"] 
            loc = 0
            r[fname] = {}
            code = ""
            for s in m["sources"]:
                for e in self.solution.exercise.elements:
                    if s == e["identifier"]:
                        r[fname][s] = {}
                        if e.get("visible") is not None:
                            r[fname][s]["visible"] = e["visible"]
                        r[fname][s]["start"] = (loc + 1)
                        code += e["value"]
                        if not code.endswith("\n"):
                            code += "\n"
                        cnt = e["value"].count("\n")
                        loc += cnt
                        r["temp"][s]["stop"] = loc if cnt != 0 else (loc + 1)
                        break
            loc += 1
            with open(os.path.join(PATH, f"{fname}.{self._fileext}"), "w+") as f:
                f.write(code)
        return r

    def getSnippetIdentifier(self, file, line):
        for i in self.fileInfo[file]:
            if line >= self.fileInfo[file][i]["start"] and line <= self.fileInfo[file][i]["stop"]:
                return i

    def getLoc(self, file, line, join=False):
        with open(file if not join else os.path.join(PATH, file), "r") as f:
            i = 0
            while i < line - 1:
                f.readline()
                i += 1
            return f.readline()

    def compile(self):
        """ Compiles all merged source files.
        """
        # changes current working directory for easier compiling
        cwd = os.getcwd()
        os.chdir(PATH)

        # array containing all filenames of files to be compiled. If that information is not 
        # given in exercise's config, all merged files will be compiled
        files = self.solution.exercise.config["compiling"].get("sources")
        files = files if files is not None else self.fileInfo

        # compiling command as specified as in exercise
        com = f"{self.solution.exercise.getCompilingCommand()} -c "
        # filenames of files to be compiled, each with the correct file extension
        com += f"{' '.join([f'{s}.{self._fileext}' for s in files])} "
        # flag for easier error handling. Requires GCC 9.4
        com += "-fdiagnostics-format=json"

        self.result.computation["technicalInfo"]["compileCommand"] = com
        proc = subprocess.run(com.split(" "), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        os.chdir(cwd)
        #self.result.computation["technicalInfo"]["compileOutput"] = proc.stdout
        #print(f"Proc Output (Len {len(proc.stdout)}):\n{proc.stdout}\n---")

        try:
            parsed = json.loads(proc.stdout.decode("utf-8"))

            if len(parsed) > 0:
                maxState = "info"
                elements = []
                for p in parsed:
                    # updating maxState if neccessary
                    if p["kind"] == "warning" and maxState == "info":
                        maxState = "warning"
                    elif p["kind"] == "error" and maxState != "error":
                        maxState = "error"

                    # file and line of error
                    file = p["locations"][0]["caret"]["file"].split(".")[0]
                    line = p["locations"][0]["caret"]["line"]

                    # calculating the line 
                    snippet = self.getSnippetIdentifier(file, line)

                    # dict specifying the current error/warning/info and source
                    e = {
                        "severity" : p["kind"],
                        "type" : "compiler",
                        "message" : p["message"],
                        "source" : {
                            "elementID" : snippet,
                            "extract" : self.getLoc(f"{file}.{self._fileext}", line, join=True),
                            "begin" : self.fileInfo[file][snippet]["start"],
                            "end" : self.fileInfo[file][snippet]["stop"],
                            "line" : line - self.fileInfo[file][snippet]["start"],
                            "col" : p["locations"][0]["caret"]["column"]
                        }
                    }
                    elements.append(e)
                    
                self.result.computation["userInfo"]["summary"] = f"[{maxState.upper()}]"
                self.result.computation["userInfo"]["elements"] = elements

        except json.decoder.JSONDecodeError:   
            parsed = proc.stdout.decode("utf-8")
            
        # adds compiling output to "elements" in result object
        data = {
            "MIMEtype":"text/plain",
            "identifier":f"{self.result.id} Compiling",
            "value" : parsed
        }
        self.result.elements.append(data)
        return proc.returncode

    def check(self):
        """ Checks all merged source files.
        Checking after compiling to reduce effort. It's unnecessary to check if compiling fails.
        """
        forbidden = self.solution.exercise.config.get("checking")
        if forbidden is None:
            return 0

        returncode = 0
        forbidden = forbidden["forbiddenCalls"].split(" ")
        checker = Checker(self.fileInfo)
        for a in checker.asts:
            checker.getFunctions(checker.asts[a])

        #print(json.dumps(checker.visitor.data, indent=4))
        elements = []

        for file in checker.visitor.data:
            f = file.split(os.sep)[-1][:-(len(self._fileext) + 1)]
            for func in checker.visitor.data[file]:
                for i in checker.visitor.data[file][func]:
                    cur = checker.visitor.data[file][func][i]
                    if self.getSnippetIdentifier(f, cur["Line"]) == "codeFromStudent" \
                        and cur["FuncCall"] in forbidden:

                        line = cur["Line"] - self.fileInfo[f]["codeFromStudent"]["start"]

                        e =  {
                            "severity": "error",
                            "type": "callcheck",
                            "message": f"[C function filtering] Function call not allowed:\n\'"
                                f"{cur['FuncCall']}\';original source: codeFromStudent, line "
                                f"(corrected): {line}, " \
                                f"col: {cur['Column']}\nForbidden calls:\nsystem.\n",
                        
                            "source": {
                                "elementID": "codeFromStudent",
                                "extract": self.getLoc(file, line),
                                "begin": self.fileInfo[f]["codeFromStudent"]["start"],
                                "end": self.fileInfo[f]["codeFromStudent"]["stop"],
                                "line": line,
                                "col": cur["Column"]
                            }
                        }
                        elements.append(e)

                        if returncode == 0:
                            returncode = 1
                        
        if len(elements) != 0:
            if "elements" not in self.result.computation["userInfo"]:
                self.result.computation["userInfo"]["elements"] = elements
            else:
                self.result.computation["userInfo"]["elements"] += elements
            
            if "summary" not in self.result.computation["userInfo"]:
                self.result.computation["userInfo"]["summary"] = "[ERROR]"
            elif "ERROR" not in self.result.computation["userInfo"]["summary"]:
                self.result.computation["userInfo"]["summary"] = "[ERROR]"

        data = {
            "MIMEtype":"text/plain",
            "identifier":f"{self.result.id} Checking",
            "value" : elements
        }
        self.result.elements.append(data)
        return returncode

    def link(self):
        """ Links compiled files and libraries.
        """
        com = f"{'gcc' if self._lang == 'C' else 'g++'} -o {os.path.join(PATH, 'out')} " \
            f"{' '.join([os.path.join(PATH, f'{s}.o') for s in self.fileInfo])}"

        flags = self.solution.exercise.config["linking"]["flags"]
        if flags is not None and flags != "":
            com += f" {flags}"

        self.result.computation["technicalInfo"]["linkCommand"] = com
        proc = subprocess.run(com.split(" "), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        data = {
            "MIMEtype":"text/plain",
            "identifier":f"{self.result.id} Linking",
            "value" : proc.stdout.decode("utf-8")
        }
        self.result.elements.append(data)
        return proc.returncode
    
    def run(self):
        """ Makes file executable and runs it.
        """
        os.chmod(os.path.join(PATH, "out"), 0o700)
        com = f"{os.path.join(PATH, 'out')}"
        cmdLineArgs = self.solution.exercise.config["running"].get("commandLineArguments")
        if cmdLineArgs is not None:
            com += f" {cmdLineArgs}"

        # Time Limit of running process
        timelimit = self.solution.exercise.config["running"].get("timelimitInSeconds")
        cfglimit = self.cfg.get("timelimitInSeconds")
        if timelimit is None:
            timelimit = cfglimit # is now either None or int
        else:
            if cfglimit is not None:
                timelimit = min(timelimit, cfglimit)

        self.result.computation["technicalInfo"]["runCommand"] = com

        proc = subprocess.Popen(com.split(" "), stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            preexec_fn=os.setsid, shell=True)
        try:
            stdout, stderr = proc.communicate(timeout=timelimit)
            text = ""
        except subprocess.TimeoutExpired as e:
            os.killpg(os.getpgid(proc.pid), signal.SIGTERM)
            text = f"Runtime failed! Timeout after {e.timeout} seconds"
            stdout, stderr = proc.communicate()
            self.result.computation["userInfo"]["summary"] = "Runtime failed! Exit code: 1"


        data = [{
            "MIMEtype":"text/plain",
            "identifier":f"{self.result.id} Running",
            "value" : text
        },
        {
            "MIMEtype":"text/plain",
            "identifier":f"{self.result.id} Running stdout",
            "value" : stdout.decode("utf-8")
        },
        {
            "MIMEtype":"text/plain",
            "identifier":f"{self.result.id} Running stderr",
            "value" : stderr.decode("utf-8")
        }]
        for d in data:
            self.result.elements.append(d)

class Checker:
    """ Class for generating Abstract Syntax Trees (AST) of source files
        and retrieving informations about function calls.
    
    Attributes:
        asts (dict):
            A dict containing one entry for each merged source file
                - key: filename (without extension)
                - value: AST of source file
    """

    def __init__(self, files: dict):
        """ Constructor

        Args:
            files (dict):
                A dict generated by the "merge" function in class "C"
        """
        self._files = files
        self.asts = self.getAsts()
        self.visitor = self.Visitor()

    class Visitor(c_ast.NodeVisitor):
        """ Internal Class for visiting nodes in an AST.
        """
        def __init__(self):
            self.data = {}
        
        def visit_FuncDef(self, node):
            """ Finds and prints all found function calls in a function
            """
            if node.decl.coord.file not in self.data:
                self.data[node.decl.coord.file] = {}
            self.data[node.decl.coord.file][node.decl.name] = {}
            #print(f"File: {node.decl.coord.file}")
            i = 0
            for n in node.body.block_items:
                if isinstance(n, c_ast.FuncCall):
                    self.data[node.decl.coord.file][node.decl.name][str(i)] = {
                        "FuncCall" : n.name.name,
                        "Line" : n.coord.line,
                        "Column" : n.coord.column
                    }
                    i += 1

    def getAst(self, filename) -> c_ast.FileAST:
        """ Generates an AST from given source file

        Args:
            filename (str):
                The name of the source file to generate an AST for
        """
        fake_libc_include = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), 
            'utils', 'fake_libc_include')
        return parse_file(filename, use_cpp=True, cpp_path="gcc",
            cpp_args=["-E", f"-I{fake_libc_include}"])

    def getAsts(self) -> dict:
        """ Generates one AST for each merged source file

        Returns:
            A dict containing one (key, value) pair for each source file.
                - key: filename (without extension)
                - value: AST for the corresponding file
        """
        asts = {}
        for f in self._files:
            asts[f] = self.getAst(os.path.join(PATH, f"{f}.c"))
        return asts
    
    def getFunctions(self, ast: c_ast.FileAST):
        """ Iterates over the given AST and visit nodes as specified as in Visitor class
        Args:
            ast:
                An AST representing a source file.
        """
        self.visitor.visit(ast)